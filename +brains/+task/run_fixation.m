function run_fixation( opts )

%   RUN -- Run the fixation task.
%
%   IN:
%     - `opts` (struct) -- Options as generated by `setup()`.

%   extract
IO =            opts.IO;
ROIS =          opts.ROIS;
TIMER =         opts.TIMER;
STATES =        opts.STATES;
TRACKER =       opts.TRACKER;
STIMULI =       opts.STIMULI;
IMAGES =        opts.IMAGES;
SOUNDS =        opts.SOUNDS;
STRUCTURE =     opts.STRUCTURE;
INTERFACE =     opts.INTERFACE;
REWARDS =       opts.REWARDS;
TIMINGS =       opts.TIMINGS;
tcp_comm =      opts.COMMUNICATORS.tcp_comm;
serial_comm =   opts.COMMUNICATORS.serial_comm;

STATES.current = STATES.new_trial;

DATA = struct();
PROGRESS = struct();
TRIAL_NUMBER = 0;
trial_in_block = 0;
trial_type_num = STRUCTURE.trial_type_nums(1);

first_entry = true;
STATES.current = STATES.new_trial;

REWARDS.pulse_timer = NaN;
REWARDS.current_frequency = REWARDS.min_frequency;
REWARDS.debounce_timer = NaN;

ALIGN_CENTER_STIMULI_TO_TOP = true;
SCREEN_HEIGHT = 27.3;
SCREEN_OFFSET = 19.5;
SCREEN_HEIGHT_PX = 768;

errors = struct();
errors.fix_not_met = false;
errors.fix_broken = false;
errors.rule_cue_fix_broken = false;
errors.train_fixation_fix_broken = false;

active_target = STIMULI.fixation;

n_correct = 0;
n_errors = 0;

while (true)
  
  %   STATE NEW_TRIAL
  if ( STATES.current == STATES.new_trial )
    Screen( 'Flip', opts.WINDOW.index );
    if ( TRIAL_NUMBER > 0 )
      tn = TRIAL_NUMBER;
      DATA(tn).trial_number = tn;
      DATA(tn).errors = errors;
      %   get N correct and incorrect
%       last_trial_n_errors = sum( structfun(@(x) x, errors) );
      any_errors = any( structfun(@(x) x, errors) );
      if ( any_errors )
        n_errors = n_errors + 1;
      else
        n_correct = n_correct + 1;
      end
      %   display data
      clc;
      disp( DATA(tn).errors );
      fprintf( '\n - Trial number: %d', tn );
%       fprintf( '\n - N errors: %d', n_errors );
      err_types = fieldnames( errors );
      for ii = 1:numel(err_types)
        n_errors = sum( arrayfun(@(x) x.errors.(err_types{ii}), DATA) );
        fprintf( '\n - N errors (%s): %d', err_types{ii}, n_errors );
      end
      fprintf( '\n - N correct: %d', n_correct );
    end
    TRIAL_NUMBER = TRIAL_NUMBER + 1;
    trial_in_block = trial_in_block + 1;
    %   reset event times
    PROGRESS = structfun( @(x) NaN, PROGRESS, 'un', false );
    PROGRESS.trial_start = TIMER.get_time( 'task' );
    errors = structfun( @(x) false, errors, 'un', false );
    if ( STRUCTURE.trials_per_block == 0 )
      if ( rand() > .5 )
        trial_type_num = 1;
      else
        trial_type_num = 2;
      end
      %   -1 for gaze, -2 for led
    elseif ( sign(STRUCTURE.trials_per_block) == -1 )
      trial_type_num = -STRUCTURE.trials_per_block;
    else
      if ( trial_in_block == STRUCTURE.trials_per_block )
        trial_in_block = 0;
        STRUCTURE.trial_type_nums = fliplr( STRUCTURE.trial_type_nums );
        trial_type_num = STRUCTURE.trial_type_nums(1);
      end
    end
    if ( rand() > .5 )
      led_index = 1;
    else
      led_index = 2;
    end
    
    %   extract stimuli
    switch ( STRUCTURE.rule_cue_type )
      case 'gaze'
        rule_cue = STIMULI.rule_cue_gaze;
      case 'led'
        rule_cue = STIMULI.rule_cue_led;
      otherwise
        error( 'Unrecognized rule cue ''%s''', STRUCTURE.rule_cue_type );
    end
    
    fix_targ = STIMULI.fixation;
    fix_picture = STIMULI.fixation_picture;
    if ( TRIAL_NUMBER == 1 && ALIGN_CENTER_STIMULI_TO_TOP )
      align_stimuli_to_top( {fix_targ, rule_cue, fix_picture} ...
        , SCREEN_HEIGHT, SCREEN_OFFSET, SCREEN_HEIGHT_PX );
%       shift_stimulus_up( fix_targ, 300 );
    end
    
    serial_comm.clear_rewards();
    TIMER.reset_timers( 'trial' );
    STRUCTURE.rule_cue_type = STRUCTURE.rule_cue_types{trial_type_num};
    STATES.current = STATES.fixation;
    REWARDS.current = REWARDS.min_frequency;
    REWARDS.current_frequency = REWARDS.min_frequency;
    REWARDS.pulse_timer = NaN;
    first_entry = true;
  end
  
  %   STATE FIXATION
  if ( STATES.current == STATES.fixation )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      TIMER.reset_timers( 'fixation' );
      fix_targ.reset_targets();
      fix_targ.blink( 0 );
      if ( isempty(SOUNDS.fixation_task_new_trial_cue.audio) )
        beep();
      else
        aud = SOUNDS.fixation_task_new_trial_cue.audio;
        fs = SOUNDS.fixation_task_new_trial_cue.fs;
        sound( aud, fs );
      end
      square_ind = strcmp( IMAGES.fixation.filenames, 'square.png' );
      fix_targ.image = IMAGES.fixation.matrices{ square_ind };
      active_target = fix_targ;
      errors.fix_broken = false;
      errors.fix_not_met = false;
      log_progress = true;
      did_show = false;
      first_entry = false;
    end
    fix_targ.update_targets();
    if ( ~did_show )
      serial_comm.reward( 1, REWARDS.fixation );
      fix_targ.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( log_progress )
      PROGRESS.fixation_onset = TIMER.get_time( 'task' );
      log_progress = false;
    end
    if ( fix_targ.duration_met() )
      TIMER.reset_timers( 'trial' );
      serial_comm.clear_rewards();
      PROGRESS.fixation_acquired = TIMER.get_time( 'task' );
      %   MARK: goto: rule cue
      STATES.current = STATES.rule_cue;
      first_entry = true;
    end
    if ( TIMER.duration_met('fixation') )
      %   MARK: goto: error
      STATES.current = STATES.error__fixation;
      errors.fix_not_met = true;
      first_entry = true;
    end
  end
  
  %   STATE RULE_CUE
  if ( STATES.current == STATES.rule_cue )
    if ( first_entry )
      TIMER.reset_timers( 'rule_cue' );
      %   draw the peripheral targets
      wrect = opts.WINDOW.rect;
      frame_width = wrect(3)/3;
      frame_height = wrect(4);
      periph_targ_names = { 'frame_cue_left', 'frame_cue_right' };
      periph_targ_place = { 'top-left', 'top-right' };
      frame_cues = struct();
      frame_cues.frame_cue_left = STIMULI.frame_cue_left;
      frame_cues.frame_cue_right = STIMULI.frame_cue_right;
      for ii = 1:numel(periph_targ_names)
        targ_name = periph_targ_names{ii};
        frame_cues.(targ_name).width = frame_width;
        frame_cues.(targ_name).len = frame_height;
        frame_cues.(targ_name).vertices = [ 0, 0, frame_width, frame_height ];
        frame_cues.(targ_name).put( periph_targ_place{ii} );
        frame_cues.(targ_name).scale( .95 );
        frame_cues.(targ_name).color = rule_cue.color;
      end
      active_target = rule_cue;
      errors.rule_cue_fix_broken = false;
      log_progress = true;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      rule_cue.draw();
      
      %   MARK: draw peripheral cues
%       structfun( @(x) x.draw_frame(), frame_cues );
      %   end draw peripheral cues
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
%     TRACKER.update_coordinates();
    rule_cue.update_targets();
    %   if fixation to the rule cue is broken, abort the trial and return
    %   to the new trial state.
    if ( ~rule_cue.in_bounds() )
      %   MARK: goto: error
      errors.rule_cue_fix_broken = true;
      STATES.current = STATES.error;
      first_entry = true;
    end
    if ( TIMER.duration_met('rule_cue') )
      %   MARK: goto: train_fixation
      STATES.current = STATES.train_fixation;
      first_entry = true;
    end
  end
  
  %   STATE TRAIN FIXATION
  if ( STATES.current == STATES.train_fixation )
    if ( first_entry )
      TIMER.reset_timers( 'train_fixation' );
      did_show = false;
      made_error = false;
      errors.train_fixation_fix_broken = false;
      fix_targ = STIMULI.fixation_picture;
      active_target = STIMULI.fixation_picture;
      image_switch_timer = tic;
      if ( INTERFACE.use_led )
        serial_comm.LED( led_index, STRUCTURE.fixation_led_duration );
      end
      first_entry = false;
    end
%     TRACKER.update_coordinates();
    if ( ~did_show || toc(image_switch_timer) > STRUCTURE.image_frequency )
      square_ind = strcmp( IMAGES.fixation.filenames, 'square.png' );
      other_images = IMAGES.fixation.matrices( ~square_ind );
      other_images = other_images( randperm(numel(other_images)) );
      img = other_images{1};
      fix_targ.image = img;
      image_switch_timer = tic;
      did_show = false;
    end
    fix_targ.update_targets();
    if ( ~did_show && ~TIMER.duration_met('train_fixation') )
      fix_targ.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( ~fix_targ.in_bounds() )
      %   MARK: goto: error;
      made_error = true;
      errors.train_fixation_fix_broken = true;
      STATES.current = STATES.error;
      first_entry = true;
    end
    if ( TIMER.duration_met('train_fixation') && ~made_error )
      %   MARK: goto: iti;
      %
      %   @FixMe
      %
      %   Remove WaitSecs; implement better reward check
      for j = 1:REWARDS.iti_pulses
        serial_comm.reward( 1, REWARDS.iti );
        WaitSecs( 0.05 );
      end
      STATES.current = STATES.iti;
      first_entry = true;
    end
  end
  
  %   STATE ERROR
  if ( STATES.current == STATES.error )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      TIMER.reset_timers( 'error' );
      err_cue = STIMULI.error_cue;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      err_cue.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( TIMER.duration_met('error') )
      %   MARK: goto: new_trial
      STATES.current = STATES.iti;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE ERRROR FIXATION
  if ( STATES.current == STATES.error__fixation )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      TIMER.reset_timers( 'error__fixation' );
      err_cue = STIMULI.fixation_error_cue;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      err_cue.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( TIMER.duration_met('error__fixation') )
      %   MARK: goto: new_trial
      STATES.current = STATES.iti;
      first_entry = true;
    end
  end
  
    %   STATE ITI
  if ( STATES.current == STATES.iti )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      PROGRESS.iti = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'iti' );
      first_entry = false;
    end
    if ( TIMER.duration_met('iti') )
      %   MARK: goto: new_trial
      STATES.current = STATES.new_trial;
      first_entry = true;
    end
  end
  
  % - Update tcp_comm
  tcp_comm.update();
  tcp_comm.send_when_ready( 'gaze', TRACKER.coordinates );
  
  % - Update targets
  TRACKER.update_coordinates();
  
  % - Check if within fix bounds
  cs = STATES.current;
  if ( active_target.in_bounds() && ...
      cs ~= STATES.error && cs ~= STATES.iti && cs ~= STATES.new_trial && ...
      cs ~= STATES.fixation && cs ~= STATES.error__fixation && ...
      TIMER.duration_met('trial') )
    
    if ( isnan(REWARDS.pulse_timer) )
      should_reward = true;
    else
      should_reward = toc(REWARDS.pulse_timer) > REWARDS.pulse_frequency/1e3;
    end
    if ( should_reward )
      serial_comm.reward( 1, REWARDS.increment );
      REWARDS.pulse_timer = tic;
    end
  end
  
  % - If an error occurred, return to the new trial.
  if ( ~isnan(tcp_comm.consume('error')) )
    %   MARK: goto: error
    STATES.current = STATES.error;
    tcp_comm.send_when_ready( 'state', STATES.current );
    first_entry = true;
  end
  
  % - Update rewards  
  if ( TIMER.duration_met('debounce_arduino_messages') )
    serial_comm.update();
    TIMER.reset_timers( 'debounce_arduino_messages' );
  end
  
  % - Quit if error in EyeLink
  success = TRACKER.check_recording();
  if ( success ~= 0 ), break; end;
  
  % - Check if key is pressed
  [key_pressed, ~, key_code] = KbCheck();
  if ( key_pressed )
    % - Quit if stop_key is pressed
    if ( key_code(INTERFACE.stop_key) ), break; end;
    %   Deliver reward if reward key is pressed
    if ( key_code(INTERFACE.rwd_key) )
      if ( isnan(REWARDS.debounce_timer) )
        should_reward_key = true;
      else
        should_reward_key = toc( REWARDS.debounce_timer ) > .5;
      end
      if ( should_reward_key )
        serial_comm.reward( 1, REWARDS.key_press );
        REWARDS.debounce_timer = tic;
      end
    end
  end
  
  % - Quit if time exceeds total time
  if ( TIMER.duration_met('task') ), break; end;
  
end

end

function align_stimuli_to_top(stim, scr_height_cm, offset, scr_height_px)
  cellfun( @(x) align_stimulus_to_top(x, scr_height_cm, offset, scr_height_px) ...
    , stim );
end

function align_stimulus_to_top(stim, scr_height_cm, offset_y_cm, screen_height_y_px)
current_height = stim.vertices(4) - stim.vertices(2);
stim.vertices([2, 4]) = [ 0, current_height ];

for i = 1:numel(stim.targets)
  new_y0 = get_target_offset(scr_height_cm, offset_y_cm, screen_height_y_px);
  new_y1 = new_y0 + current_height;
  stim.targets{i}.bounds(2) = new_y0;
  stim.targets{i}.bounds(4) = new_y1;
end

end

function pixel_offset = get_target_offset( scr_height_cm, offset_y_cm, screen_height_y_px )

pixel_offset = (offset_y_cm / scr_height_cm) * screen_height_y_px;

end

%align_stimuli_to_top( {fix_targ, rule_cue, fix_picture}, 19.5, 27.3 );

function shift_stimulus_up(stim, amt)
stim.vertices([2, 4]) = stim.vertices([2, 4]) - amt;
end