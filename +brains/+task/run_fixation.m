function run_fixation( opts )

%   RUN -- Run the fixation task.
%
%   IN:
%     - `opts` (struct) -- Options as generated by `setup()`.

%   extract
IO =            opts.IO;
ROIS =          opts.ROIS;
TIMER =         opts.TIMER;
STATES =        opts.STATES;
TRACKER =       opts.TRACKER;
STIMULI =       opts.STIMULI;
IMAGES =        opts.IMAGES;
STRUCTURE =     opts.STRUCTURE;
INTERFACE =     opts.INTERFACE;
REWARDS =       opts.REWARDS;
TIMINGS =       opts.TIMINGS;
tcp_comm =      opts.COMMUNICATORS.tcp_comm;
serial_comm =   opts.COMMUNICATORS.serial_comm;

STATES.current = STATES.new_trial;

DATA = struct();
PROGRESS = struct();
TRIAL_NUMBER = 0;
trial_in_block = 0;
trial_type_num = STRUCTURE.trial_type_nums(1);

first_entry = true;
STATES.current = STATES.new_trial;

REWARDS.pulse_timer = NaN;
REWARDS.current_frequency = REWARDS.min_frequency;
REWARDS.debounce_timer = NaN;

errors = struct();
errors.fix_not_met = false;
errors.fix_broken = false;
errors.rule_cue_fix_broken = false;
errors.train_fixation_fix_broken = false;

active_target = STIMULI.fixation;

n_correct = 0;
n_errors = 0;

while (true)
  
  %   STATE NEW_TRIAL
  if ( STATES.current == STATES.new_trial )
    Screen( 'Flip', opts.WINDOW.index );
    if ( TRIAL_NUMBER > 0 )
      tn = TRIAL_NUMBER;
      DATA(tn).trial_number = tn;
      DATA(tn).errors = errors;
      %   get N correct and incorrect
      last_trial_n_errors = sum( structfun(@(x) x, errors) );
      if ( last_trial_n_errors > 0 )
        n_errors = n_errors + 1;
      else
        n_correct = n_correct + 1;
      end
      %   display data
      clc;
      disp( DATA(tn).errors );
      fprintf( '\n - Trial number: %d', tn );
      fprintf( '\n - N errors: %d', n_errors );
      fprintf( '\n - N correct: %d', n_correct );
    end
    TRIAL_NUMBER = TRIAL_NUMBER + 1;
    trial_in_block = trial_in_block + 1;
    %   reset event times
    PROGRESS = structfun( @(x) NaN, PROGRESS, 'un', false );
    PROGRESS.trial_start = TIMER.get_time( 'task' );
    errors = structfun( @(x) false, errors, 'un', false );
    if ( STRUCTURE.trials_per_block == 0 )
      if ( rand() > .5 )
        trial_type_num = 1;
      else
        trial_type_num = 2;
      end
      %   -1 for gaze, -2 for led
    elseif ( sign(STRUCTURE.trials_per_block) == -1 )
      trial_type_num = -STRUCTURE.trials_per_block;
    else
      if ( trial_in_block == STRUCTURE.trials_per_block )
        trial_in_block = 0;
        STRUCTURE.trial_type_nums = fliplr( STRUCTURE.trial_type_nums );
        trial_type_num = STRUCTURE.trial_type_nums(1);
      end
    end
    serial_comm.clear_rewards();
    TIMER.reset_timers( 'trial' );
    STRUCTURE.rule_cue_type = STRUCTURE.rule_cue_types{trial_type_num};
    STATES.current = STATES.fixation;
    REWARDS.current = REWARDS.min_frequency;
    REWARDS.current_frequency = REWARDS.min_frequency;
    REWARDS.pulse_timer = NaN;
    first_entry = true;
  end
  
  %   STATE FIXATION
  if ( STATES.current == STATES.fixation )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      TIMER.reset_timers( 'fixation' );
      fix_targ = STIMULI.fixation;
      fix_targ.reset_targets();
      fix_targ.blink( 0 );
      %   SHIFT FIXATION SQUARE UP
      if ( TRIAL_NUMBER == 1 )
        fix_targ.vertices([2, 4]) = fix_targ.vertices([2, 4]) - 0;
      end
      square_ind = strcmp( IMAGES.fixation.filenames, 'square.png' );
      fix_targ.image = IMAGES.fixation.matrices{ square_ind };
      active_target = fix_targ;
      errors.fix_broken = false;
      errors.fix_not_met = false;
      log_progress = true;
      did_show = false;
      first_entry = false;
    end
    fix_targ.update_targets();
    if ( ~did_show )
      fix_targ.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( log_progress )
      PROGRESS.fixation_onset = TIMER.get_time( 'task' );
      log_progress = false;
    end
    if ( fix_targ.duration_met() )
      TIMER.reset_timers( 'trial' );
      serial_comm.clear_rewards();
      PROGRESS.fixation_acquired = TIMER.get_time( 'task' );
      %   MARK: goto: rule cue
      STATES.current = STATES.rule_cue;
      first_entry = true;
    end
    if ( TIMER.duration_met('fixation') )
      %   MARK: goto: error
      STATES.current = STATES.error;
      errors.fix_not_met = true;
      first_entry = true;
    end
  end
  
  %   STATE RULE_CUE
  if ( STATES.current == STATES.rule_cue )
    if ( first_entry )
      TIMER.reset_timers( 'rule_cue' );
      switch ( STRUCTURE.rule_cue_type )
        case 'gaze'
          rule_cue = STIMULI.rule_cue_gaze;
        case 'led'
          rule_cue = STIMULI.rule_cue_led;
        otherwise
          error( 'Unrecognized rule cue ''%s''', STRUCTURE.rule_cue_type );
      end
      %   draw the peripheral targets
      wrect = opts.WINDOW.rect;
      frame_width = wrect(3)/3;
      frame_height = wrect(4);
      periph_targ_names = { 'frame_cue_left', 'frame_cue_right' };
      periph_targ_place = { 'top-left', 'top-right' };
      frame_cues = struct();
      frame_cues.frame_cue_left = STIMULI.frame_cue_left;
      frame_cues.frame_cue_right = STIMULI.frame_cue_right;
      for ii = 1:numel(periph_targ_names)
        targ_name = periph_targ_names{ii};
        frame_cues.(targ_name).width = frame_width;
        frame_cues.(targ_name).len = frame_height;
        frame_cues.(targ_name).vertices = [ 0, 0, frame_width, frame_height ];
        frame_cues.(targ_name).put( periph_targ_place{ii} );
        frame_cues.(targ_name).scale( .95 );
        frame_cues.(targ_name).color = rule_cue.color;
      end
      active_target = rule_cue;
      errors.rule_cue_fix_broken = false;
      log_progress = true;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      rule_cue.draw();
      
      %   MARK: draw peripheral cues
%       structfun( @(x) x.draw_frame(), frame_cues );
      %   end draw peripheral cues
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
%     TRACKER.update_coordinates();
    rule_cue.update_targets();
    %   if fixation to the rule cue is broken, abort the trial and return
    %   to the new trial state.
    if ( ~rule_cue.in_bounds() )
      %   MARK: goto: error
      errors.rule_cue_fix_broken = true;
      STATES.current = STATES.error;
      first_entry = true;
    end
    if ( TIMER.duration_met('rule_cue') )
      %   MARK: goto: train_fixation
      STATES.current = STATES.train_fixation;
      first_entry = true;
    end
  end
  
  %   STATE TRAIN FIXATION
  if ( STATES.current == STATES.train_fixation )
    if ( first_entry )
      TIMER.reset_timers( 'train_fixation' );
      did_show = false;
      made_error = false;
      errors.train_fixation_fix_broken = false;
      fix_targ = STIMULI.fixation_picture;
      active_target = STIMULI.fixation_picture;
      image_switch_timer = tic;
      first_entry = false;
    end
%     TRACKER.update_coordinates();
    if ( ~did_show || toc(image_switch_timer) > STRUCTURE.image_frequency )
      square_ind = strcmp( IMAGES.fixation.filenames, 'square.png' );
      other_images = IMAGES.fixation.matrices( ~square_ind );
      other_images = other_images( randperm(numel(other_images)) );
      img = other_images{1};
      fix_targ.image = img;
      image_switch_timer = tic;
      did_show = false;
    end
    fix_targ.update_targets();
    if ( ~did_show )
      fix_targ.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( ~fix_targ.in_bounds() )
      %   MARK: goto: error;
      made_error = true;
      errors.train_fixation_fix_broken = true;
      STATES.current = STATES.error;
      first_entry = true;
    end
    if ( TIMER.duration_met('train_fixation') && ~made_error )
      %   MARK: goto: iti;
      STATES.current = STATES.iti;
      first_entry = true;
    end
  end
  
  %   STATE ERROR
  if ( STATES.current == STATES.error )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      TIMER.reset_timers( 'error' );
      err_cue = STIMULI.error_cue;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      err_cue.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( TIMER.duration_met('error') )
      %   MARK: goto: new_trial
      STATES.current = STATES.new_trial;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
    %   STATE ITI
  if ( STATES.current == STATES.iti )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      PROGRESS.iti = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'iti' );
      serial_comm.reward( 1, REWARDS.main );
      first_entry = false;
    end
    if ( TIMER.duration_met('iti') )
      %   MARK: goto: new_trial
      STATES.current = STATES.new_trial;
      first_entry = true;
    end
  end
  
  % - Update tcp_comm
  tcp_comm.update();
  tcp_comm.send_when_ready( 'gaze', TRACKER.coordinates );
  
  % - Update targets
  TRACKER.update_coordinates();
  
  % - Check if within fix bounds
  cs = STATES.current;
  if ( active_target.in_bounds() && ...
      cs ~= STATES.error && cs ~= STATES.iti && cs ~= STATES.new_trial && ...
      cs ~= STATES.fixation && TIMER.duration_met('trial') )
    
    if ( isnan(REWARDS.pulse_timer) )
      should_reward = true;
    else
      should_reward = toc(REWARDS.pulse_timer) > REWARDS.pulse_frequency/1e3;
    end
    if ( should_reward )
      serial_comm.reward( 1, REWARDS.increment );
      REWARDS.pulse_timer = tic;
    end
  end
  
  % - If an error occurred, return to the new trial.
  if ( ~isnan(tcp_comm.consume('error')) )
    %   MARK: goto: error
    STATES.current = STATES.error;
    tcp_comm.send_when_ready( 'state', STATES.current );
    first_entry = true;
  end
  
  % - Update rewards  
  if ( TIMER.duration_met('debounce_arduino_messages') )
    serial_comm.update();
    TIMER.reset_timers( 'debounce_arduino_messages' );
  end
  
  % - Quit if error in EyeLink
  success = TRACKER.check_recording();
  if ( success ~= 0 ), break; end;
  
  % - Check if key is pressed
  [key_pressed, ~, key_code] = KbCheck();
  if ( key_pressed )
    % - Quit if stop_key is pressed
    if ( key_code(INTERFACE.stop_key) ), break; end;
    %   Deliver reward if reward key is pressed
    if ( key_code(INTERFACE.rwd_key) )
      if ( isnan(REWARDS.debounce_timer) )
        should_reward_key = true;
      else
        should_reward_key = toc( REWARDS.debounce_timer ) > .5;
      end
      if ( should_reward_key )
        serial_comm.reward( 1, REWARDS.key_press );
        REWARDS.debounce_timer = tic;
      end
    end
  end
  
  % - Quit if time exceeds total time
  if ( TIMER.duration_met('task') ), break; end;
  
end

end