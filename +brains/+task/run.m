function run( opts )

%   RUN -- Run the task.
%
%   IN:
%     - `opts` (struct) -- Options as generated by `setup()`.

%   extract
IO =            opts.IO;
ROIS =          opts.ROIS;
TIMER =         opts.TIMER;
STATES =        opts.STATES;
TRACKER =       opts.TRACKER;
STIMULI =       opts.STIMULI;
STRUCTURE =     opts.STRUCTURE;
INTERFACE =     opts.INTERFACE;
REWARDS =       opts.REWARDS;
TIMINGS =       opts.TIMINGS;
tcp_comm =      opts.COMMUNICATORS.tcp_comm;
serial_comm =   opts.COMMUNICATORS.serial_comm;

first_entry = true;
STATES.current = STATES.new_trial;

DATA = struct();
PROGRESS = struct();
TRIAL_NUMBER = 0;
FRAMES.stp = 1;
FRAMES.mean = NaN;
FRAMES.min = Inf;
FRAMES.max = -Inf;

%   main loop
while ( true )
  
  %   STATE NEW_TRIAL
  if ( STATES.current == STATES.new_trial )
    Screen( 'Flip', opts.WINDOW.index );
    disp( 'Entered new_trial' );
    if ( TRIAL_NUMBER > 0 )
      tn = TRIAL_NUMBER;
      DATA(tn).trial_number = tn;
      DATA(tn).m1_chose = STRUCTURE.m1_chose;
      DATA(tn).m2_chose = STRUCTURE.m2_chose;
      DATA(tn).rule_cue_type = STRUCTURE.rule_cue_type;
      DATA(tn).correct_location = correct_location;
      DATA(tn).incorrect_location = incorrect_location;
      DATA(tn).events = PROGRESS;
    end
    TRIAL_NUMBER = TRIAL_NUMBER + 1;
    %   reset event times
    PROGRESS = structfun( @(x) NaN, PROGRESS, 'un', false );
    %   determine rule cue type
    if ( INTERFACE.IS_M1 )
      if ( rand() > .5 )
        STRUCTURE.rule_cue_type = 'gaze';
        trial_type_num = 1;
      else
        STRUCTURE.rule_cue_type = 'led';
        trial_type_num = 2;
      end
      tcp_comm.send_when_ready( 'trial_type', trial_type_num );
    else
      trial_type_num = tcp_comm.await_data( 'trial_type' );
      %   make sure we received a valid `laser_location`, unless
      %   require_synch is false.
      if ( isnan(trial_type_num) )
        assert( ~INTERFACE.require_synch, 'Received NaN for trial_type.' );
        trial_type_num = 1;
      end
      if ( trial_type_num == 1 )
        STRUCTURE.rule_cue_type = 'gaze';
      else
        STRUCTURE.rule_cue_type = 'led';
      end
    end
    %   get correct target location for m2
    if ( rand() > .5 )
      incorrect_location = 'center-left';
      correct_location = 'center-right';
      incorrect_is = 1;
      correct_is = 2;
    else
      incorrect_location = 'center-right';
      correct_location = 'center-left';
      incorrect_is = 2;
      correct_is = 1;
    end
    %   make the laser cue appear on the side opposite of the gaze target.
    if ( ~INTERFACE.IS_M1 )
      led_location = incorrect_is;
      tcp_comm.send_when_ready( 'choice', led_location );
    else
      led_location = tcp_comm.await_data( 'choice' );
      %   make sure we received a valid `laser_location`, unless
      %   require_synch is false.
      if ( isnan(led_location) )
        assert( ~INTERFACE.require_synch, 'Received NaN for laser_location.' );
        led_location = 1;
      end
    end
    disp( 'Trialtype is:' );
    disp( STRUCTURE.rule_cue_type );
    %   set fixation delay time
    if ( INTERFACE.IS_M1 )
      fix_delays = TIMINGS.delays.fixation_delay;
      ind = randperm( numel(fix_delays) );
      fixation_delay_time = fix_delays( ind(1) );
      tcp_comm.send_when_ready( 'delay', fixation_delay_time );
    else
      fixation_delay_time = tcp_comm.await_data( 'delay' );
      if ( isnan(fixation_delay_time) )
        assert( ~INTERFACE.require_synch, 'Received NaN for fixation_delay.' );
        fixation_delay_time = TIMINGS.delays.fixation_delay(1);
      end
    end
    %   reset choice parameters
    STRUCTURE.m1_chose = [];
    STRUCTURE.m2_chose = [];
    %   get type of cue for this trial
    %   MARK: goto: fixation
    STATES.current = STATES.fixation;
    tcp_comm.send_when_ready( 'state', STATES.current );
    first_entry = true;
  end
  
  %   STATE FIXATION
  if ( STATES.current == STATES.fixation )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      disp( 'Entered fixation' );
      tcp_comm.await_matching_state( STATES.current );
      TIMER.reset_timers( 'fixation' );
      fix_targ = STIMULI.fixation;
      fix_targ.reset_targets();
      fix_targ.blink( 0 );
      %   SHIFT FIXATION SQUARE UP
      if ( TRIAL_NUMBER == 1 )
        fix_targ.vertices([2, 4]) = fix_targ.vertices([2, 4]) - 0;
      end
      log_progress = true;
      fix_met = 0;
      tcp_comm.send_when_ready( 'fix_met', fix_met );
      first_entry = false;
    end
    tcp_comm.update();
    TRACKER.update_coordinates();
    structfun( @(x) x.update(), ROIS );
    fix_targ.update_targets();
    fix_targ.draw();
    Screen( 'Flip', opts.WINDOW.index );
    if ( log_progress )
      PROGRESS.fixation_onset = TIMER.get_time( 'task' );
      log_progress = false;
    end
    if ( fix_targ.duration_met() )
      disp( 'Met fixation' );
      PROGRESS.fixation_acquired = TIMER.get_time( 'task' );
      if ( INTERFACE.require_synch )
        other_fix_met = tcp_comm.consume( 'fix_met' ) == 1;
      else other_fix_met = 1;
      end
      fix_met = 1;
      if ( other_fix_met )
        if ( INTERFACE.require_synch && INTERFACE.IS_M1 )
          serial_comm.reward( 1, REWARDS.bridge );
          serial_comm.reward( 2, REWARDS.bridge );
        elseif ( ~INTERFACE.require_synch )
          serial_comm.reward( 1, REWARDS.bridge );
        end
        %   MARK: goto: rule cue
        STATES.current = STATES.rule_cue;
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
    else
      fix_met = 0;
    end
    tcp_comm.send_when_ready( 'fix_met', fix_met );
    if ( TIMER.duration_met('fixation') )
      %   MARK: goto: rule cue
      STATES.current = STATES.rule_cue;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE RULE_CUE
  if ( STATES.current == STATES.rule_cue )
    if ( first_entry )
      disp( 'Entered rule cue' );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.rule_cue = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'rule_cue' );
      switch ( STRUCTURE.rule_cue_type )
        case 'gaze'
          rule_cue = STIMULI.rule_cue_gaze;
        case 'led'
          rule_cue = STIMULI.rule_cue_led;
        otherwise
          error( 'Unrecognized rule cue ''%s''', STRUCTURE.rule_cue_type );
      end
      log_progress = true;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      rule_cue.draw_frame();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    TRACKER.update_coordinates();
    rule_cue.update_targets();
    %   if fixation to the rule cue is broken, abort the trial and return
    %   to the new trial state.
    if ( ~rule_cue.in_bounds() )
      %   MARK: goto: error
      tcp_comm.send_when_ready( 'error', 2 );
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    if ( tcp_comm.consume('error') == 2 )
      %   MARK: goto: error
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    if ( log_progress )
      PROGRESS.rule_cue_onset = TIMER.get_time( 'task' );
      log_progress = false;
    end
    if ( TIMER.duration_met('rule_cue') )
      %   MARK: goto: cue_display
      STATES.current = STATES.cue_display;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE CUE_DISPLAY
  if ( STATES.current == STATES.cue_display ) 
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      disp( 'Entered cue_display' );
      PROGRESS.rule_cue_offset = TIMER.get_time( 'task' );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.post_rule_cue = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'cue_display' );
      is_gaze_trial = strcmp( STRUCTURE.rule_cue_type, 'gaze' );
      is_m2 = ~INTERFACE.IS_M1;
      if ( is_gaze_trial )
        correct_target = STIMULI.gaze_cue_correct;
        incorrect_target = STIMULI.gaze_cue_incorrect;
        incorrect_target.put( incorrect_location );
        correct_target.put( correct_location );
        incorrect_target.reset_targets();
        correct_target.reset_targets();
      end
      last_pulse = NaN;
      log_progress = true;
      lit_led = false;
      did_show = false;
      first_entry = false;
    end
    TRACKER.update_coordinates();
    fix_targ.update_targets();
    if ( is_m2 && is_gaze_trial )
      incorrect_target.update_targets();
      correct_target.update_targets();
      if ( ~did_show )
        incorrect_target.draw();
        correct_target.draw();
        Screen( 'Flip', opts.WINDOW.index );
        did_show = true;
      end
      if ( log_progress )
        PROGRESS.m2_target_onset = TIMER.get_time( 'task' );
        log_progress = false;
      end
      if ( correct_target.duration_met() )
        fprintf( '\nM2: made choice %d\n', correct_is );
        if ( isnan(last_pulse) )
          should_reward = true;
        else
          should_reward = toc( last_pulse ) > REWARDS.pulse_frequency;
        end
        if ( should_reward )
          serial_comm.reward( 1, REWARDS.main );
          last_pulse = tic;
        end
        STRUCTURE.m2_chose = correct_is;
        tcp_comm.send_when_ready( 'choice', correct_is );
        if ( ~INTERFACE.require_synch )
          %   MARK: goto: FIXATION_DELAY
          STATES.current = STATES.fixation_delay;
          first_entry = true;
        end
      end
      if ( incorrect_target.duration_met() )
        fprintf( '\nM2: made choice %d\n', incorrect_is );
        STRUCTURE.m2_chose = incorrect_is;
        tcp_comm.send_when_ready( 'choice', incorrect_is );
        if ( ~INTERFACE.require_synch )
          %   MARK: goto: FIXATION_DELAY
          STATES.current = STATES.fixation_delay;
          first_entry = true;
        end
      end
    elseif ( is_m2 && ~is_gaze_trial )
      if ( ~lit_led )
        serial_comm.LED( led_location, opts.TIMINGS.LED );
        lit_led = true;
      end
      if ( ~did_show )
        fix_targ.draw();
        Screen( 'Flip', opts.WINDOW.index );
        did_show = true;
      end
      if ( ~fix_targ.in_bounds() )
        %   MARK: goto: error
        tcp_comm.send_when_ready( 'error', 3 );
        STATES.current = STATES.error;
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
    else
      Screen( 'Flip', opts.WINDOW.index );
    end
    if ( tcp_comm.consume('error') == 3 )
      %   MARK: goto: error
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    if ( TIMER.duration_met('cue_display') )
      %   MARK: goto: fixation_delay
      if ( is_m2 && isempty(STRUCTURE.m2_chose) )
        tcp_comm.send_when_ready( 'choice', 0 );
        STRUCTURE.m2_chose = 0;
      end
      STATES.current = STATES.fixation_delay;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE FIXATION_DELAY  
  if ( STATES.current == STATES.fixation_delay )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      disp( 'Entered fixation_delay' );
      tcp_comm.await_matching_state( STATES.current );
      tcp_comm.consume( 'fix_met' );
      PROGRESS.fixation_delay = TIMER.get_time( 'task' );
      TIMER.set_durations( 'fixation_delay', Inf );
      TIMER.reset_timers( {'fixation_delay', 'pre_fixation_delay'} );
      fix_targ.reset_targets();
      did_show = false;
      did_look = false;
      is_fixating = 0;
      did_begin_timer = false;
      made_error = false;
      first_entry = false;
    end
    TRACKER.update_coordinates();
    fix_targ.update_targets();
    if ( ~did_show )
      fix_targ.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( fix_targ.in_bounds() )
      is_fixating = 1;
      did_look = true;
    elseif ( did_look )
      made_error = true;
      tcp_comm.send_when_ready( 'error', 4 );
       %   MARK: goto: error
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    tcp_comm.send_when_ready( 'fix_met', is_fixating );
    if ( INTERFACE.require_synch )
      other_is_fixating = tcp_comm.consume( 'fix_met' );
      other_is_fixating = ~isnan( other_is_fixating ) && other_is_fixating > 0;
    else
      other_is_fixating = 1;
    end
    if ( other_is_fixating && is_fixating )
      if ( ~did_begin_timer )
        TIMER.set_durations( 'fixation_delay', fixation_delay_time );
        TIMER.reset_timers( 'fixation_delay' );
        did_begin_timer = true;
      end
    end
    if ( tcp_comm.consume('error') == 4 )
      made_error = true;
      %   MARK: goto: error
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    if ( TIMER.duration_met('fixation_delay') && ~made_error )
      %   MARK: goto: response
      STATES.current = STATES.response;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
    if ( TIMER.duration_met('pre_fixation_delay') && ~did_look )
      tcp_comm.send_when_ready( 'error', 4 );
      %   MARK: goto: error
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE RESPONSE
  if ( STATES.current == STATES.response )
    if ( first_entry )
      Screen( 'Flip', opts.WINDOW.index );
      disp( 'Entered response' );
      PROGRESS.m2_target_offset = TIMER.get_time( 'task' );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.response = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'response' );
      response_target1 = STIMULI.response_target1;
      response_target2 = STIMULI.response_target2;
      response_target1.reset_targets();
      response_target2.reset_targets();
      fix_targ.reset_targets();
      if ( INTERFACE.IS_M1 )
        STRUCTURE.m2_chose = tcp_comm.await_data( 'choice' );
        fprintf( '\nM1: Received choice value %d\n', STRUCTURE.m2_chose );
      else
        tcp_comm.consume( 'choice' );
      end
      STRUCTURE.m1_chose = [];
      did_show = false;
      made_error = false;
      first_entry = false;
    end
    TRACKER.update_coordinates();
    fix_targ.update_targets();
    if ( INTERFACE.IS_M1 )
      response_target1.update_targets();
      response_target2.update_targets();
      if ( ~did_show )
        response_target1.draw();
        response_target2.draw();
        Screen( 'Flip', opts.WINDOW.index );
        did_show = true;
      end
      if ( response_target1.duration_met() )
        fprintf( '\nM1: made choice %d\n', 1 );
        STRUCTURE.m1_chose = 1;
        %   MARK: goto: evaluate_choice
        STATES.current = STATES.evaluate_choice;
        tcp_comm.send_when_ready( 'choice', 1 );
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
      if ( response_target2.duration_met() )
        fprintf( '\nM1: made choice %d\n', 2 );
        STRUCTURE.m1_chose = 2;
        %   MARK: goto: evaluate_choice
        STATES.current = STATES.evaluate_choice;
        tcp_comm.send_when_ready( 'choice', 2 );
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
    else
      if ( ~did_show )
        fix_targ.draw();
        Screen( 'Flip', opts.WINDOW.index );
        did_show = true;
      end
      if ( ~fix_targ.in_bounds() )
        made_error = true;
        tcp_comm.send_when_ready( 'error', 5 );
        %   MARK: goto: error;
        STATES.current = STATES.error;
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
      received_m1_choice = tcp_comm.consume( 'choice' );
      if ( ~isnan(received_m1_choice) && ~made_error )
        fprintf( '\nM2: Received choice value: %d\n', received_m1_choice );
        STRUCTURE.m1_chose = received_m1_choice;
        %   MARK: goto: evaluate_choice
        STATES.current = STATES.evaluate_choice;
        tcp_comm.send_when_ready( 'state', STATES.current );
        first_entry = true;
      end
    end
    if ( tcp_comm.consume('error') == 5 )
      %   MARK: goto: error;
      STATES.current = STATES.error;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    elseif ( TIMER.duration_met('response') )
      if ( INTERFACE.IS_M1 && isempty(STRUCTURE.m1_chose) )
        tcp_comm.send_when_ready( 'choice', 0 );
        STRUCTURE.m1_chose = 0;
      end
      if ( ~INTERFACE.IS_M1 && isnan(received_m1_choice) )
        received_m1_choice = tcp_comm.await_data( 'choice' );
        STRUCTURE.m1_chose = received_m1_choice;
        fprintf( '\nM2: Received choice value: %d\n', received_m1_choice );
      end
      %   MARK: goto: evaluate_choice
      STATES.current = STATES.evaluate_choice;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE EVALUATE_CHOICE
  if ( STATES.current == STATES.evaluate_choice )
    if ( first_entry )
      disp( 'Entered evaluate_choie' );
      Screen( 'Flip', opts.WINDOW.index );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.evaluate_choice = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'evaluate_choice' );
      m1_chose = STRUCTURE.m1_chose;
      m2_chose = STRUCTURE.m2_chose;
      fprintf( '\nM1 chose: %d', m1_chose );
      fprintf( '\nM2 chose: %d', m2_chose );
      both_made_choices = m1_chose ~= 0 && m2_chose ~= 0;
      %   a left choice (1) for m1 is a right choice (2) for m2. So, e.g,
      %   for a laser trial, if the correct laser location is 2, the
      %   correct choice for m1 is 1.
      matching_choices = both_made_choices && abs( m1_chose-m2_chose ) == 1;
      matching_laser = both_made_choices && abs( m1_chose-led_location ) == 1;
      if ( INTERFACE.IS_M1 )
        %   if trialtype is 'gaze', and choices match ...
        if ( strcmp(STRUCTURE.rule_cue_type, 'gaze') && matching_choices )
          serial_comm.reward( 1, REWARDS.main );
          serial_comm.reward( 2, REWARDS.main );
        %   if trialtype is 'laser', and m1's choice matches laser_location
        elseif ( strcmp(STRUCTURE.rule_cue_type, 'laser') && matching_laser )
          serial_comm.reward( 1, REWARDS.main );
          serial_comm.reward( 2, REWARDS.main );
        else
          disp( 'M1 was not correct' );
        end
      end
      first_entry = false;
    end
    if ( TIMER.duration_met('evaluate_choice') )
      %   MARK: goto: iti
      STATES.current = STATES.iti;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE ITI
  if ( STATES.current == STATES.iti )
    if ( first_entry )
      disp( 'Entered ITI' );
      Screen( 'Flip', opts.WINDOW.index );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.iti = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'iti' );
      first_entry = false;
    end
    if ( TIMER.duration_met('iti') )
      %   MARK: goto: new_trial
      STATES.current = STATES.new_trial;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  %   STATE ERROR
  if ( STATES.current == STATES.error )
    if ( first_entry )
      disp( 'Entered error' );
      Screen( 'Flip', opts.WINDOW.index );
      tcp_comm.await_matching_state( STATES.current );
      PROGRESS.error = TIMER.get_time( 'task' );
      TIMER.reset_timers( 'error' );
      err_cue = STIMULI.error_cue;
      did_show = false;
      first_entry = false;
    end
    if ( ~did_show )
      err_cue.draw();
      Screen( 'Flip', opts.WINDOW.index );
      did_show = true;
    end
    if ( TIMER.duration_met('error') )
      %   MARK: goto: new_trial
      STATES.current = STATES.new_trial;
      tcp_comm.send_when_ready( 'state', STATES.current );
      first_entry = true;
    end
  end
  
  % - Determine frame times.
  if ( INTERFACE.DEBUG )
    if ( FRAMES.stp > 1 )
      FRAMES.current = TIMER.get_time( 'task' );
      FRAMES.delta = FRAMES.current - FRAMES.last;
      FRAMES.last = FRAMES.current;
      FRAMES.min = min( [FRAMES.min, FRAMES.delta] );
      FRAMES.max = max( [FRAMES.max, FRAMES.delta] );
      if ( FRAMES.stp == 2 )
        FRAMES.mean = FRAMES.delta;
      else
        N1 = FRAMES.stp - 1;
        N2 = FRAMES.stp - 2;
        FRAMES.mean = (FRAMES.mean*N2 + FRAMES.delta) / N1;
      end
    else
      FRAMES.last = TIMER.get_time( 'task' );
    end
    FRAMES.stp = FRAMES.stp + 1;
  end
  
  if ( INTERFACE.DEBUG )
    disp( TRACKER.coordinates );
  end
  
  % - Update tcp_comm
  tcp_comm.update();
  tcp_comm.send_when_ready( 'gaze', TRACKER.coordinates );
  
  % - If an error occurred, return to the new trial.
  if ( ~isnan(tcp_comm.consume('error')) )
    %   MARK: goto: error
    STATES.current = STATES.error;
    tcp_comm.send_when_ready( 'state', STATES.current );
    first_entry = true;
  end
  
  % - Update rewards  
  if ( TIMER.duration_met('debounce_arduino_messages') )
    serial_comm.update();
    TIMER.reset_timers( 'debounce_arduino_messages' );
  end
  
  % - Quit if error in EyeLink
  success = TRACKER.check_recording();
  if ( success ~= 0 ), break; end;
  
  % - Check if key is pressed
  [key_pressed, ~, key_code] = KbCheck();
  if ( key_pressed )
    % - Quit if stop_key is pressed
    if ( key_code(INTERFACE.stop_key) ), break; end;
    %   Deliver reward if reward key is pressed
    if ( key_code(INTERFACE.rwd_key) )
      serial_comm.reward( 1, REWARDS.main );
    end
  end
  
  % - Quit if time exceeds total time
  if ( TIMER.duration_met('task') ), break; end;
end

TRACKER.shutdown();

if ( INTERFACE.save_data )
  data = struct();
  data.DATA = DATA;
  data.opts = opts;
  data.opts.FRAMES = FRAMES;
  save( fullfile(IO.data_folder, IO.data_file), 'data' );
end

end