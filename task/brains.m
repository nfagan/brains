function err = brains(is_master_arduino, is_master_monkey)

%   BRAINS -- Configure and run the brains task.
%
%     IN:
%       - `is_master_arduino` (true, false) -- Specify whether the current
%         computer is connected to the master or slave arduino
%       - `is_master_monkey` (true, false) -- Specify whether the current
%         computer will begin in the master or slave 

opts = setup( is_master_arduino, is_master_monkey );

try
  run( opts );
  err = 0;
catch err
  cleanup( opts );
  commandwindow;
  fprintf( '\n\n%s', err.message );
end

end

function opts = setup( is_master_arduino, is_master_monkey )

%   SETUP -- Define constants and initial settings.
%
%   OUT:
%     - `opts` (struct)

addpath( './helpers' );

% - IO - %
IO.edf_filename = 'tstx.edf';

% - SCREEN - %
SCREEN.index = 0;
SCREEN.background_color = [ 0 0 0 ];

% - WINDOW - %
WINDOW.index = [];
WINDOW.width = [];
WINDOW.height = [];
WINDOW.rect = [];
WINDOW.center = [];

% - INTERFACE - %
INTERFACE.use_mouse = false;
INTERFACE.use_eyelink = true;
INTERFACE.use_arduino = true;
INTERFACE.stop_key = 'space';
INTERFACE.is_master_arduino = is_master_arduino;

% - STRUCTURE - %
STRUCTURE.is_master_monkey = is_master_monkey;
STRUCTURE.correct_choice = [];
STRUCTURE.rule_cue_type = 'gaze';

% - STATES - %
STATES.pre_fixation = 0;
STATES.fixation = 1;
STATES.synchronize = 2;
STATES.rule_cue = 3;
STATES.post_rule_cue = 4;
STATES.use_rule = 5;
STATES.current = [];

% - TIMINGS - %
TIMINGS.timer_ids.main = [];  % id of main timer
TIMINGS.timer_ids.fixation = [];
TIMINGS.timer_ids.rule_cue = [];
TIMINGS.timer_ids.post_rule_cue = [];
TIMINGS.timer_ids.use_rule = [];
TIMINGS.timer_ids.last_arduino_message = [];

TIMINGS.start = 0;
TIMINGS.last_frame = 0;
TIMINGS.cumulative_fixation = 0;
TIMINGS.fixation_duration = 2; % seconds required to fixate.
TIMINGS.total_time = Inf; % total experiment time.
TIMINGS.synchronization_timeout = 5;  % seconds before synchronization is deemed unsuccessful.

TIMINGS.time_in.fixation = Inf;
TIMINGS.time_in.rule_cue = 2;
TIMINGS.time_in.post_rule_cue = 1;
TIMINGS.time_in.use_rule = 1;

TIMINGS.debounce_arduino_messages = .001;  % seconds before a new message can be sent to the arduino.

% - COMMUNICATOR - %
if ( is_master_arduino )
  messages = { ...
    struct('message', 'SYNCHRONIZE', 'char', 'S'), ...
    struct('message', 'REWARD1', 'char', 'A'), ...
    struct('message', 'REWARD2', 'char', 'B'), ...
    struct('message', 'PRINT_GAZE', 'char', 'P'), ...
    struct('message', 'COMPARE_STATES', 'char', 'W' ), ...
    struct('message', 'COMPARE_GAZE', 'char', 'L') ...
  };
  port = 'COM4';
else
  messages = { ...
    struct('message', 'SYNCHRONIZE', 'char', 'S'), ...
    struct('message', 'REWARD1', 'char', 'M'), ...
    struct('message', 'REWARD2', 'char', 'N'), ...
    struct('message', 'PRINT_GAZE', 'char', 'P'), ...
    struct('message', 'COMPARE_STATES', 'char', 'W' ), ...
    struct('message', 'COMPARE_GAZE', 'char', 'L') ...
  };
  port = 'COM4';
end
baud_rate = 115200;
if ( INTERFACE.use_arduino )
  COMMUNICATOR = Communicator( messages, port, baud_rate );
else COMMUNICATOR = [];
end

% - STIMULI - %
STIMULI.fixation.position = 'center';
STIMULI.fixation.color = [];
STIMULI.fixation.shape = 'square';
STIMULI.fixation.size = 100;

STIMULI.rule_cue_gaze_left.position = 'left';
STIMULI.rule_cue_gaze_left.color = [];
STIMULI.rule_cue_gaze_left.shape = 'square';
STIMULI.rule_cue_gaze_left.size = 100;

STIMULI.rule_cue_gaze_right.position = 'right';
STIMULI.rule_cue_gaze_right.color = [];
STIMULI.rule_cue_gaze_right.shape = 'square';
STIMULI.rule_cue_gaze_right.size = 100;

% - REWARDS - %
REWARDS.main = 100; % ms
REWARDS.last_reward_size = []; % ms

%   output as one struct

opts.IO =           IO;
opts.SCREEN =       SCREEN;
opts.INTERFACE =    INTERFACE;
opts.WINDOW =       WINDOW;
opts.TIMINGS =      TIMINGS;
opts.STRUCTURE =    STRUCTURE;
opts.STATES =       STATES;
opts.COMMUNICATOR = COMMUNICATOR;
opts.STIMULI =      STIMULI;
opts.REWARDS =      REWARDS;

end

function run(opts)

%   RUN -- Run the task.
%
%   IN:
%     - `opts` (struct) -- Options as generated by `setup()`.

%   initialize EyeLink connections, etc.
PsychDefaultSetup( 1 );
ListenChar( 2 );
err = eyeTrackingInit( opts );
assert( ~err, 'Eyelink initialization failed.' );

%   reset arduino
opts = reset_arduino( opts );

%   open windows
SCREEN = opts.SCREEN;
[windex, wrect] = Screen( 'OpenWindow', SCREEN.index, SCREEN.background_color, [], 32 );
opts.WINDOW.center = round( [mean(wrect([1 3])), mean(wrect([2 4]))] );
opts.WINDOW.index = windex;
opts.WINDOW.rect = wrect;

%   define starting state
opts.STATES.current = opts.STATES.synchronize;

%   start timing
timer_ids = fieldnames( opts.TIMINGS.timer_ids );
for i = 1:numel(timer_ids)
  opts = reset_timer( opts, timer_ids{i} );
end
opts.TIMINGS.start = get_time( opts, 'main' );
opts.TIMINGS.last_frame = opts.TIMINGS.start;

%   main loop
while ( true )
  
  %   STATE SYNCHRONIZE
  if ( opts.STATES.current == opts.STATES.synchronize )
    synch_success = false;
    while ( ~synch_success )
      synch_success = synchronize( opts );
    end
    %   MARK: goto: pre_fixation
    opts.STATES.current = opts.STATES.pre_fixation;
  end
  
  %   STATE PRE_FIXATION
  if ( opts.STATES.current == opts.STATES.pre_fixation )
    clear_screen( opts );
    opts.TIMINGS.cumulative_fixation = 0;
    opts.TIMINGS.last_frame = get_time( opts, 'main' );
    opts = reset_timer( opts, 'fixation' );
    %   MARK: goto: fixation
    opts.STATES.current = opts.STATES.fixation;
    opts = debounce_arduino( opts, @set_state, opts.STATES.current );
  end
  
  %   STATE FIXATION
  if ( opts.STATES.current == opts.STATES.fixation )
%     opts = await_matching_state( opts );
    %   where is the stimulus to be placed?
    stimulus_bounds = get_square_stimulus_bounds( opts, 'center', opts.STIMULI.fixation.size );
    %   draw the rectangle at that location
    draw_rect( opts, stimulus_bounds, opts.STIMULI.fixation.color );
    %   display it
    Screen( 'Flip', opts.WINDOW.index );
    %   continuousy check whether gaze coordinates fall within the stimulus
    %   bounds, and update the cumulative time spent fixating as
    %   appropriate.
    opts = update_cumulative_fixation_time( opts, stimulus_bounds, 'cumulative_fixation' );
    opts = debounce_arduino( opts, @update_arduino_gaze );
    if ( opts.TIMINGS.cumulative_fixation >= opts.TIMINGS.fixation_duration )
      %   determine whether the gaze matches the gaze of the other monkey.
      [opts, m2_gaze_matches] = debounce_arduino( opts, @gazes_match );
      if ( m2_gaze_matches )
        %   MARK: goto: rule cue
        opts.STATES.current = opts.STATES.rule_cue;
      end
    end
    if ( get_time(opts, 'fixation') > opts.TIMINGS.time_in.fixation )
      %   do something
    end
  end
  
  %   STATE RULE_CUE
  if ( opts.STATES.current == opts.STATES.rule_cue )
    if ( opts.STRUCTURE.is_master_monkey )
      switch ( opts.STRUCTURE.rule_cue_type )
        case 'gaze'
          left_cue_size = opts.STIMULI.rule_cue_gaze_left.size;
          right_cue_size = opts.STIMULI.rule_cue_gaze_right.size;
          %   get bounds for left and right cues
          left_stimulus_bounds = get_square_stimulus_bounds( opts, 'left', left_cue_size );
          right_stimulus_bounds = get_square_stimulus_bounds( opts, 'right', right_cue_size );
          %   draw the rectangles at those locations
          draw_rect( opts, left_stimulus_bounds, opts.STIMULI.rule_cue_gaze_left.color );
          draw_rect( opts, right_stimulus_bounds, opts.STIMULI.rule_cue_gaze_right.color );
        case 'laser'
          %   fill in
        otherwise
          error( 'Unrecognized rule_cue_type ''%s''', opts.STRUCTURE.rule_cue_type );
      end
      Screen( 'Flip', opts.WINDOW.index );
    else
      clear_screen( opts );
    end
    if ( get_time(opts, 'rule_cue') > opts.TIMINGS.time_in.rule_cue )
      %   MARK: goto: post_rule_cue
      opts.STATES.current = opts.STATES.post_rule_cue;
    end
  end
  
  %   STATE POST_RULE_CUE  
  if ( opts.STATES.current == opts.STATES.post_rule_cue )
    clear_screen( opts );
    if ( get_time(opts, 'post_rule_cue') > opts.TIMINGS.time_in.post_rule_cue )
      %   MARK: goto: USE_RULE
      opts.STATES.current = opts.STATES.use_rule;
    end
  end
  
  %   STATE USE_RULE
  if ( opts.STATES.current == opts.STATES.use_rule )
    opts = update_cumulative_fixation_time( opts, left_stimulus_bounds, 'left_option' );
    opts = update_cumulative_fixation_time( opts, right_stimulus_bounds, 'right_option' );
    if ( get_time(opts, 'use_rule') > opts.TIMINGS.time_in.use_rule )
      break;
      %   do something
    end
  end
  
  %   Quit if error in EyeLink
  err = checkRecording( opts );
  if ( err ~= 0 )
    break;
  end
  %   Quit if key is pressed
  [key_pressed, ~, ~] = KbCheck();
  if ( key_pressed )
    break;
  end
  %   Quit if time exceeds total time
  total_elapsed_time = get_time( opts, 'main' ) - opts.TIMINGS.start;
  if ( total_elapsed_time > opts.TIMINGS.total_time )
    break;
  end
end

opts = debounce_arduino( opts, @set_state, 0 );
[opts, matches] = debounce_arduino( opts, @states_match );
disp( 'Do the states match?' );
disp( matches );
disp( 'Do the gazes match?' );
[opts, matches] = debounce_arduino( opts, @gazes_match );
disp( matches );
ListenChar(1);
sca;

shutdownEyelink( opts );   
cleanup( opts );

end

function opts = update_cumulative_fixation_time(opts, bounds, timing_type)

%   UPDATE_CUMULATIVE_FIXATION_TIME -- Update the total amount of time
%     spent fixating on a given target.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `bounds` (double) -- 4-element vector specifying valid fixation
%         boundaries (i.e., the vertices of the stimulus).
%       - `timing_type` (char) -- String corresponding to the cumulative
%         fixation variable to update.
%     OUT:
%       - `opts` (struct) -- Updated `opts` struct.

if ( ~newGazeDataReady(opts) || ~opts.INTERFACE.use_eyelink )
  return;
end

[gaze_success, gaze_x, gaze_y] = getGazeCoordinates( opts );

if ( ~gaze_success )
  return;
end

within_x = gaze_x >= bounds(1) && gaze_x < bounds(3);
within_y = gaze_y >= bounds(2) && gaze_y < bounds(4);

if ( within_x && within_y )
  delta = get_time(opts, 'main') - opts.TIMINGS.last_frame;
  opts.TIMINGS.(timing_type) = opts.TIMINGS.(timing_type) + delta;
else
  opts.TIMINGS.(timing_type) = 0;
end

opts.TIMINGS.last_frame = get_time( opts, 'main' );

end

function bounds = get_square_stimulus_bounds(opts, placement, sz)

%   GET_SQUARE_STIMULUS_BOUNDS -- Get vertices of a square of a given size,
%     placed in a given portion of the screen.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `placement` (char) -- Placement specifier. Current options are
%         'center'.
%       - `sz` (double) |SCALAR| -- Single number specifying the size (in
%         pixels) of the square.
%     OUT:
%       - `bounds` (double) -- 4-element row vector specifying the vertices
%         / bounds of the square.

center = opts.WINDOW.center;
position = round( [-sz/2, -sz/2, sz/2, sz/2] );

switch ( placement )
  case 'center'
    center = [ center, center ];
    bounds = center + position;
  case 'left'
    center_left = center - center/2;
    center_left = [ center_left, center_left ];
    bounds = center_left + position;
  case 'right'
    center_right = center + center/2;
    center_right = [ center_right, center_right ];
    bounds = center_right + position;
  otherwise
    error( 'Unrecognized object placement ''%s''', placement );
end

end

function draw_rect(opts, rect, color)

%   DRAW_RECT -- Display a rectangle of the specified dimensions and color.
%
%     IN:
%       - `opts` (struct) -- Options struct as generated by `setup()`.
%       - `rect` (double) -- 4-element vector specifying [x1, y1, x2, y2].
%       - `color` (double) -- 3-element vector specifying the fill-color.

window = opts.WINDOW.index;
Screen( 'FillRect', window, color, rect );

end

function clear_screen(opts)

%   CLEAR_SCREEN -- Fill the screen with the screen's background color.
%
%     IN:
%       - `opts` (struct) -- Options struct as generated by `setup()`.

color = opts.SCREEN.background_color;
rect = opts.WINDOW.rect;
window = opts.WINDOW.index;
draw_rect( opts, rect, color );
Screen( 'Flip', window );

end

function assert_isa(variable, kind, variable_name)

%   ASSERT_ISA -- Ensure a variable is of a given class.
%
%     IN:
%       - `variable` (/any/) -- Variable to check.
%       - `kind` (char) -- Expected class of `variable`.
%       - `variable_name` (char) |OPTIONAL| -- Optionally specify the
%         variable name to appear in the error text, if the assertion
%         fails.
  
if ( nargin < 3 ), variable_name = 'input'; end;
assert( isa(variable, kind), 'Expected %s to be a %s; was a %s' ...
  , variable_name, kind, class(variable) );
  
end





%{
    ARDUINO
%}





function opts = reset_arduino( opts )

%   RESET_ARDUINO -- Reset the states and gaze data to their defaults.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%     OUT:
%       - `opts` (struct)

opts.COMMUNICATOR.send_gaze( 'X', 0 );
opts.COMMUNICATOR.send_gaze( 'Y', 0 );
opts = set_state( opts, 0 );

end

function opts = update_arduino_gaze( opts )

%   UPDATE_ARDUINO_GAZE -- Send new gaze coordinates to the arduino.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%     OUT:
%       - `opts` (struct)

if ( ~newGazeDataReady(opts) || ~opts.INTERFACE.use_eyelink )
  return;
end

[gaze_success, gaze_x, gaze_y] = getGazeCoordinates( opts );

if ( ~gaze_success )
  return;
end

opts.COMMUNICATOR.send_gaze( 'X', round(gaze_x) );
opts.COMMUNICATOR.send_gaze( 'Y', round(gaze_y) );

end

function success = synchronize(opts)

%   SYNCHRONIZE -- Ensure two tasks running on two separate computers
%     proceed at the same time, via arduino communication.
%
%     IN:
%       - `opts` (struct) -- Options struct as obtained by `setup()`.
%     OUT:
%       - `success` (logical) |SCALAR| -- True if the response from the
%         other Arduino matches the communicator's 'synchronize' character.

communicator = opts.COMMUNICATOR;

if ( ~opts.INTERFACE.use_arduino )
  success = true;
  return;
end

if ( opts.INTERFACE.is_master_arduino )
  communicator.send( 'SYNCHRONIZE' );
end

synch_start = get_time( opts, 'main' );
success = false;

while ( communicator.communicator.bytesAvailable == 0 )
  current_time = get_time( opts, 'main' );
  synch_timed_out = current_time-synch_start > opts.TIMINGS.synchronization_timeout;
  if ( synch_timed_out )
    return;
  end
end

response = communicator.receive();
if ( isequal(response, communicator.get_char('SYNCHRONIZE')) )
  success = true;
end

end

function opts = await_matching_state( opts )

%   AWAIT_MATCHING_STATE -- Pause execution until computers are in the same
%     state.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%     OUT:
%       - `opts` (struct) -- Options struct updated to reflect the last
%         call to an arduino function.


matching_state = false;
while ( ~matching_state )
  [opts, matching_state] = debounce_arduino( opts, @states_match );
end
    
end

function [opts, tf] = matches_other( opts, message )

%   MATCHES_OTHER -- Determine whether the current computer's value matches
%     the other computer's value.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `message` (char) -- Message to send to the arduino.

opts.COMMUNICATOR.send( message );
response = opts.COMMUNICATOR.await_and_return_non_null();

tf = false;

switch( response )
  case '1'
    tf = true;
    return;
  case '0'
    return;
  otherwise
    error( 'Unrecognized response ''%s''', response );
end

end

function [opts, tf] = states_match( opts )

%   STATES_MATCH -- Return whether the two computers are in the same state.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%     OUT:
%       - `tf` (true, false)

[opts, tf] = matches_other( opts, 'COMPARE_STATES' );

end

function [opts, tf] = gazes_match( opts )

%   GAZES_MATCH -- Return whether the two monkeys are gazing in the same
%     location.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%     OUT:
%       - `tf` (true, false)

[opts, tf] = matches_other( opts, 'COMPARE_GAZE' );

end

function opts = set_state( opts, state_num )

%   SET_STATE -- Update the Arduino's state variable.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `state_num` (int)
%
%     OUT:
%       - `opts` (struct) -- Options struct updated to reflect the last
%         call to `set_state()`.

opts.COMMUNICATOR.send_state( state_num );

end

function varargout = debounce_arduino( opts, func, varargin )

%   DEBOUNCE_ARDUINO -- Ensure messages are not sent too quickly to the
%     arduino.
%
%     The function passed to `debounce_arduino()` will not be called until
%     at least `opts.TIMINGS.debounce_arduino_messages` seconds have
%     elapsed since the last input to the arduino.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `func` (function_handle) -- Function to be called.
%       - `varargin` (/any/) |OPTIONAL| -- Any additional arguments to be
%         passed to the call to `func`.
%     OUT:
%       - `varargout` (/any/) -- Various outputs as required by `func`.

if ( ~opts.INTERFACE.use_arduino )
  return;
end

while ( get_time(opts, 'last_arduino_message') < opts.TIMINGS.debounce_arduino_messages )
  % wait.
end
opts = reset_timer( opts, 'last_arduino_message' );
[varargout{1:nargout()}] = func( opts, varargin{:} );

end

function opts = set_reward_size( opts, index, sz )

%   SET_REWARD_SIZE -- Set the reward size (in ms) for the given index.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `index` (double, int) -- I.e., 1 or 2, usually.
%       - `sz` (double, int) -- Reward size in ms.
%     OUT:
%       - `opts` (struct) -- Options struct updated to reflect the last
%         reward size sent.

if ( ~opts.INTERFACE.use_arduino )
  return;
end
communicator = opts.COMMUNICATOR;
%   get the character associated with the given reward index.
reward_char = communicator.get_char( ['REWARD' num2str(index)] );
communicator.send_reward_size( reward_char, sz );
opts.REWARDS.last_reward_size = sz;

end

function opts = reward( opts, index, sz )

%   REWARD -- Send a reward associated with a given index.
%
%     If no reward size is specified, the hard-coded default (i.e., the
%     size specified in master.ino or slave.ino) will be used. Otherwise,
%     the reward size will be updated if it is different from the last
%     recorded reward size.

last_size = opts.REWARDS.last_reward_size;

if ( isempty(last_size) || sz ~= last_size )
  opts = set_reward_size( opts, index, sz );
end

reward_str = sprintf( 'REWARD%d', index );
opts.COMMUNICATOR.send( reward_str );

end

%{
    TIMERS
%}

function t = get_time( opts, id_name )

%   GET_TIME -- Get the elapsed time associated with the given timer id.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `id_name` (char) -- Fieldname of the timer_ids struct in
%         opts.TIMING.
%     OUT:
%       - `t` (double) -- Elapsed time.

t = toc( opts.TIMINGS.timer_ids.(id_name) );

end

function opts = reset_timer( opts, id_name )

%   RESET_TIMER -- Reset the timer associated with the given id.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `id_name` (char) -- Fieldname of the timer_ids struct in
%         opts.TIMING.
%     OUT:
%       - `opts` (struct) -- Updated options struct.

opts.TIMINGS.timer_ids.(id_name) = tic;

end



%   old routines



%Cleanup routine:
function cleanup(opts)
%Restore keyboard output to Matlab:
ListenChar( 0 );

use_mouse = opts.INTERFACE.use_mouse;
use_eyelink = opts.INTERFACE.use_eyelink;

% finish up: stop recording eye-movements,
% close graphics window, close data file and shut down tracker
if ( ~use_mouse && use_eyelink )
  Eyelink( 'Shutdown' );
end

opts.COMMUNICATOR.stop();

sca;

close_ports();
end
%Runs Eyelink Initialization procedures
function err = eyeTrackingInit(opts)

err = false;

if ( ~opts.INTERFACE.use_eyelink )
  return;
end

use_mouse = opts.INTERFACE.use_mouse;
if ( use_mouse )
  return; 
end

edf_file = opts.IO.edf_filename;

is_dummy_mode = 0;
success = EyelinkInit( is_dummy_mode, 1 );	

if ( ~success )
  err = true; 
  return;
end

Eyelink( 'command', 'link_event_data = GAZE,GAZERES,HREF,AREA,VELOCITY' );
Eyelink( 'command', 'link_event_filter = LEFT,RIGHT,FIXATION,BLINK,SACCADE,BUTTON' );
Eyelink( 'Openfile', edf_file );
Eyelink( 'StartRecording' );
end

%Returns a boolean indicating whether there is new gaze data available
function data_ready = newGazeDataReady(opts)

use_mouse = opts.INTERFACE.use_mouse;
if ( use_mouse )
  data_ready = true;
  return;
end
   
data_ready = Eyelink( 'NewFloatSampleAvailable' ) > 0;
end

%Returns the gaze coordinates and a bool indicating wether or not the query was successful
function [success, x, y] = getGazeCoordinates(opts)

persistent eye_used;
persistent el;

use_mouse = opts.INTERFACE.use_mouse;
window = opts.WINDOW.index;

if ( ~use_mouse && isempty(eye_used) )
  eye_used = -1;

  %Grab default Eyelink values
  el = EyelinkInitDefaults( window );
end

success = false;
x = 0;
y = 0;
if ( use_mouse )
  [x, y] = GetMouse();
  success = true;
  return;
end

event = Eyelink('NewestFloatSample');
if ( eye_used ~= -1 )
  %Get Eye Coordinates
  x = event.gx(eye_used+1);
  y = event.gy(eye_used+1);

  %If we have valid data
  if (x~=el.MISSING_DATA && y~=el.MISSING_DATA && event.pa(eye_used+1)>0)
    %then the data is valid
    success = true;
  end
else
  eye_used = Eyelink( 'EyeAvailable' );
  if (eye_used == el.BINOCULAR)
    eye_used = el.LEFT_EYE;
  end
  return;
end
end

%Checks the status of the Eyelink Recording
function err = checkRecording(opts)

  use_mouse = opts.INTERFACE.use_mouse;
	err = false;
	if ( use_mouse )
		return;
  end
	err = Eyelink( 'CheckRecording' );
end

%Close down the Eyelink connection and download the file.
function shutdownEyelink(opts)

if ( ~opts.INTERFACE.use_eyelink )
  return;
end

edf_filename = opts.IO.edf_filename;

WaitSecs( 0.1 );
Eyelink( 'StopRecording' );
WaitSecs( 0.1 );
Eyelink( 'CloseFile' );
WaitSecs( 0.1 );

try
  fprintf( 'Receiving data file ''%s''\n', edf_filename );
  %   Request the file
  status = Eyelink( 'ReceiveFile', edf_filename, pwd, 1 );
  if ( status > 0 )
    fprintf( 'ReceiveFile status %d\n', status );
  end
  WaitSecs(0.1);
  if ( exist( edf_filename, 'file' ) == 2 )
    fprintf( 'Data file ''%s'' can be found in ''%s''\n', edf_filename, pwd );
  end
catch err
    fprintf( 'Problem receiving data file ''%s''\n', edf_filename );
    fprintf( '\n%s', err.message );
end

end