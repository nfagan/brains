function brains(is_master)

%   BRAINS -- Configure and run the brains task.
%
%     IN:
%       - `is_master` (true, false) -- Specify whether the current computer
%         is the master or slave computer.

opts = setup( is_master );

try
  run( opts );
catch err
  fprintf( '\n%s', err.message );
  cleanup( opts );
  commandwindow;
end

end

function opts = setup( is_master )

%   SETUP -- Define constants and initial settings.
%
%   OUT:
%     - `opts` (struct)

addpath( './helpers' );

% - IO - %
IO.edf_filename = 'tstx.edf';

% - SCREEN - %
SCREEN.index = 0;
SCREEN.background_color = [ 0 0 0 ];

% - WINDOW - %
WINDOW.index = [];
WINDOW.width = [];
WINDOW.height = [];
WINDOW.rect = [];
WINDOW.center = [];

% - INTERFACE - %
INTERFACE.use_mouse = false;
INTERFACE.use_eyelink = false;
INTERFACE.stop_key = 'space';
INTERFACE.is_master = is_master;

% - STATES - %
STATES.pre_fixation = 0;
STATES.fixation = 1;
STATES.synchronize = 2;
STATES.current = [];

% - TIMINGS - %
TIMINGS.timer_ids.main = [];  % id of main timer
TIMINGS.start = 0;
TIMINGS.last_frame = 0;
TIMINGS.cumulative_fixation = 0;
TIMINGS.fixation_duration = 1;
TIMINGS.total_time = Inf; % total experiment time.
TIMINGS.synchronization_timeout = 5;  % seconds before synchronization is deemed unsuccessful.

% - COMMUNICATOR - %
if ( is_master )
  messages = { ...
    struct('message', 'SYNCHRONIZE', 'char', 'S'), ...
    struct('message', 'REWARD1', 'char', 'A'), ...
    struct('message', 'REWARD2', 'char', 'B'), ...
    struct('message', 'PRINT_GAZE', 'char', 'P'), ...
    struct('message', 'COMPARE', 'char', 'C' ) ...
  };
  port = 'COM4';
else
  messages = { ...
    struct('message', 'SYNCHRONIZE', 'char', 'S'), ...
    struct('message', 'REWARD1', 'char', 'M'), ...
    struct('message', 'REWARD2', 'char', 'N'), ...
    struct('message', 'PRINT_GAZE', 'char', 'P'), ...
    struct('message', 'COMPARE', 'char', 'C' ) ...
  };
  port = 'COM4';
end
baud_rate = 115200;
COMMUNICATOR = Communicator( messages, port, baud_rate );

% - STIMULI - %
STIMULI.fixation.position = 'center';
STIMULI.fixation.color = [];
STIMULI.fixation.shape = 'square';
STIMULI.fixation.size = 100;

% - REWARDS - %
REWARDS.main = 100; % ms

%   output as one struct

opts.IO =           IO;
opts.SCREEN =       SCREEN;
opts.INTERFACE =    INTERFACE;
opts.WINDOW =       WINDOW;
opts.TIMINGS =      TIMINGS;
opts.STATES =       STATES;
opts.COMMUNICATOR = COMMUNICATOR;
opts.STIMULI =      STIMULI;
opts.REWARDS =      REWARDS;

end

function run(opts)

%   RUN -- Run the task.
%
%   IN:
%     - `opts` (struct) -- Options as generated by `setup()`.

%   Initialize EyeLink connections, etc.

PsychDefaultSetup( 1 );
ListenChar( 2 );
err = eyeTrackingInit( opts );
assert( ~err, 'Eyelink initialization failed.' );

%   open windows

SCREEN = opts.SCREEN;
[windex, wrect] = Screen( 'OpenWindow', SCREEN.index, SCREEN.background_color, [], 32 );
opts.WINDOW.center = round( [mean(wrect([1 3])), mean(wrect([2 4]))] );
opts.WINDOW.index = windex;
opts.WINDOW.rect = wrect;

%   extract communicator

communicator = opts.COMMUNICATOR;

%   set main reward size

set_reward_size( opts, 1, opts.REWARDS.main );
set_reward_size( opts, 2, opts.REWARDS.main );

%   define starting state

opts.STATES.current = opts.STATES.synchronize;

%   start timing

opts.TIMINGS.timer_ids.main = tic;
opts.TIMINGS.start = get_time( opts, 'main' );
opts.TIMINGS.last_frame = opts.TIMINGS.start;

%   main loop

while ( true )
  
  %   STATE SYNCHRONIZE
  if ( opts.STATES.current == opts.STATES.synchronize )
    synch_success = false;
    while ( ~synch_success )
      synch_success = synchronize( opts, communicator );
    end
    opts.STATES.current = opts.STATES.pre_fixation;
  end
  
  %   STATE PRE_FIXATION
  if ( opts.STATES.current == opts.STATES.pre_fixation )
    clear_screen( opts );
    opts.TIMINGS.cumulative_fixation = 0;
    opts.TIMINGS.last_frame = get_time( opts, 'main' );
    opts.STATES.current = opts.STATES.fixation;
  end
  
  %   STATE FIXATION
  if ( opts.STATES.current == opts.STATES.fixation )
    %   where is the stimulus to be placed?
    stimulus_bounds = get_square_stimulus_bounds( opts, 'center', opts.STIMULI.fixation.size );
    %   draw the rectangle at that location
    draw_rect( opts, stimulus_bounds, opts.STIMULI.fixation.color );
    %   display it
    Screen( 'Flip', opts.WINDOW.index );
    %   continuousy check whether gaze coordinates fall within the stimulus
    %   bounds, and update the cumulative time spent fixating as
    %   appropriate.
    opts = update_cumulative_fixation_time( opts, stimulus_bounds, 'cumulative_fixation' );
    if ( opts.TIMINGS.cumulative_fixation > opts.TIMINGS.fixation_duration )
      communicator.send( 'REWARD1' );
      break;
    end
  end
  
  %   Quit if error in EyeLink
  err = checkRecording( opts );
  if ( err ~= 0 )
    break;
  end
  %   Quit if space was pressed
  [~, ~, key_code] = KbCheck();
  if ( key_code(opts.INTERFACE.stop_key) )
    break;
  end
  %   Quit if time exceeds total time
  total_elapsed_time = get_time( opts, 'main' ) - opts.TIMINGS.start;
  if ( total_elapsed_time > opts.TIMINGS.total_time )
    break;
  end
end

shutdownEyelink( opts );   
cleanup( opts );

end

function opts = update_cumulative_fixation_time(opts, bounds, timing_type)

%   UPDATE_CUMULATIVE_FIXATION_TIME -- Update the total amount of time
%     spent fixating on a given target.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `bounds` (double) -- 4-element vector specifying valid fixation
%         boundaries (i.e., the vertices of the stimulus).
%       - `timing_type` (char) -- String corresponding to the cumulative
%         fixation variable to update.
%     OUT:
%       - `opts` (struct) -- Updated `opts` struct.

if ( ~newGazeDataReady(opts) )
  return;
end

[gaze_success, gaze_x, gaze_y] = getGazeCoordinates( opts );

if ( ~gaze_success )
  return;
end

within_x = gaze_x >= bounds(1) && gaze_x < bounds(3);
within_y = gaze_y >= bounds(2) && gaze_y < bounds(4);

if ( within_x && within_y )
  delta = get_time(opts, 'main') - opts.TIMINGS.last_frame;
  opts.TIMINGS.(timing_type) = opts.TIMINGS.(timing_type) + delta;
else
  opts.TIMINGS.(timing_type) = 0;
end

opts.TIMINGS.last_frame = get_time( opts, 'main' );

end

function bounds = get_square_stimulus_bounds(opts, placement, sz)

%   GET_SQUARE_STIMULUS_BOUNDS -- Get vertices of a square of a given size,
%     placed in a given portion of the screen.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `placement` (char) -- Placement specifier. Current options are
%         'center'.
%       - `sz` (double) |SCALAR| -- Single number specifying the size (in
%         pixels) of the square.
%     OUT:
%       - `bounds` (double) -- 4-element row vector specifying the vertices
%         / bounds of the square.

switch ( placement )
  case 'center'
    position = round( [-sz/2, -sz/2, sz/2, sz/2] );
    center = [ opts.WINDOW.center, opts.WINDOW.center ];
    bounds = center + position;
  otherwise
    error( 'Unrecognized object placement ''%s''', placement );
end

end

function draw_rect(opts, rect, color)

%   DRAW_RECT -- Display a rectangle of the specified dimensions and color.
%
%     IN:
%       - `opts` (struct) -- Options struct as generated by `setup()`.
%       - `rect` (double) -- 4-element vector specifying [x1, y1, x2, y2].
%       - `color` (double) -- 3-element vector specifying the fill-color.

window = opts.WINDOW.index;
Screen( 'FillRect', window, color, rect );

end

function clear_screen(opts)

%   CLEAR_SCREEN -- Fill the screen with the screen's background color.
%
%     IN:
%       - `opts` (struct) -- Options struct as generated by `setup()`.

color = opts.SCREEN.background_color;
rect = opts.WINDOW.rect;
window = opts.WINDOW.index;
draw_rect( opts, rect, color );
Screen( 'Flip', window );

end

function assert_isa(variable, kind, variable_name)

%   ASSERT_ISA -- Ensure a variable is of a given class.
%
%     IN:
%       - `variable` (/any/) -- Variable to check.
%       - `kind` (char) -- Expected class of `variable`.
%       - `variable_name` (char) |OPTIONAL| -- Optionally specify the
%         variable name to appear in the error text, if the assertion
%         fails.
  
if ( nargin < 3 ), variable_name = 'input'; end;
assert( isa(variable, kind), 'Expected %s to be a %s; was a %s' ...
  , variable_name, kind, class(variable) );
  
end

function success = synchronize(opts, communicator)

%   SYNCHRONIZE -- Ensure two tasks running on two separate computers
%     proceed at the same time, via arduino communication.
%
%     IN:
%       - `opts` (struct) -- Options struct as obtained by `setup()`.
%       - `communicator` (Communicator) -- Arduino communicator object.
%     OUT:
%       - `success` (logical) |SCALAR| -- True if the response from the
%         other Arduino matches the communicator's 'synchronize' character.

if ( opts.INTERFACE.is_master )
  communicator.send( 'SYNCHRONIZE' );
end

synch_start = get_time( opts, 'main' );
success = false;

while ( communicator.communicator.bytesAvailable == 0 )
  current_time = get_time( opts, 'main' );
  synch_timed_out = current_time-synch_start > opts.TIMINGS.synchronization_timeout;
  if ( synch_timed_out )
    return;
  end
end

response = communicator.receive();
if ( isequal(response, communicator.get_char('SYNCHRONIZE')) )
  success = true;
end

end

function set_reward_size( opts, index, sz )

%   SET_REWARD_SIZE -- Set the reward size (in ms) for the given index.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `index` (double, int) -- I.e., 1 or 2, usually.
%       - `sz` (double, int) -- Reward size in ms.

communicator = opts.COMMUNICATOR;
%   get the character associated with the given reward index.
reward_char = communicator.get_char( ['REWARD' num2str(index)] );
communicator.send_reward_size( reward_char, sz );

end

function t = get_time( opts, id_name )

%   GET_TIME -- Get the elapsed time associated with the given timer id.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `id_name` (char) -- Fieldname of the timer_ids struct in
%         opts.TIMING.
%     OUT:
%       - `t` (double) -- Elapsed time.

t = toc( opts.TIMINGS.timer_ids.(id_name) );

end

function opts = reset_timer( opts, id_name )

%   RESET_TIMER -- Reset the timer associated with the given id.
%
%     IN:
%       - `opts` (struct) -- Options struct.
%       - `id_name` (char) -- Fieldname of the timer_ids struct in
%         opts.TIMING.
%     OUT:
%       - `opts` (struct) -- Updated options struct.

opts.TIMINGS.timer_ids.(id_name) = tic;

end



%   old routines



%Cleanup routine:
function cleanup(opts)
%Restore keyboard output to Matlab:
ListenChar( 0 );

use_mouse = opts.INTERFACE.use_mouse;
use_eyelink = opts.INTERFACE.use_eyelink;

% finish up: stop recording eye-movements,
% close graphics window, close data file and shut down tracker
if ( ~use_mouse && use_eyelink )
  Eyelink( 'Shutdown' );
end

opts.COMMUNICATOR.stop();

sca;
end
%Runs Eyelink Initialization procedures
function err = eyeTrackingInit(opts)

err = false;

if ( ~opts.INTERFACE.use_eyelink )
  return;
end

use_mouse = opts.INTERFACE.use_mouse;
if ( use_mouse )
  return; 
end

edf_file = opts.IO.edf_filename;

is_dummy_mode = 0;
success = EyelinkInit( is_dummy_mode, 1 );	

if ( ~success )
  err = true; 
  return;
end

Eyelink( 'command', 'link_event_data = GAZE,GAZERES,HREF,AREA,VELOCITY' );
Eyelink( 'command', 'link_event_filter = LEFT,RIGHT,FIXATION,BLINK,SACCADE,BUTTON' );
Eyelink( 'Openfile', edf_file );
Eyelink( 'StartRecording' );
end

%Returns a boolean indicating whether there is new gaze data available
function data_ready = newGazeDataReady(opts)

use_mouse = opts.INTERFACE.use_mouse;
if ( use_mouse )
  data_ready = true;
  return;
end
   
data_ready = Eyelink( 'NewFloatSampleAvailable' ) > 0;
end

%Returns the gaze coordinates and a bool indicating wether or not the query was successful
function [success, x, y] = getGazeCoordinates(opts)

persistent eye_used;
persistent el;

use_mouse = opts.INTERFACE.use_mouse;
window = opts.WINDOW.index;

if ( ~use_mouse && isempty(eye_used) )
  eye_used = -1;

  %Grab default Eyelink values
  el = EyelinkInitDefaults( window );
end

success = false;
x = 0;
y = 0;
if ( use_mouse )
  [x, y] = GetMouse();
  success = true;
  return;
end

event = Eyelink('NewestFloatSample');
if ( eye_used ~= -1 )
  %Get Eye Coordinates
  x = event.gx(eye_used+1);
  y = event.gy(eye_used+1);

  %If we have valid data
  if (x~=el.MISSING_DATA && y~=el.MISSING_DATA && event.pa(eye_used+1)>0)
    %then the data is valid
    success = true;
  end
else
  eye_used = Eyelink( 'EyeAvailable' );
  if (eye_used == el.BINOCULAR)
    eye_used = el.LEFT_EYE;
  end
  return;
end
end

%Checks the status of the Eyelink Recording
function err = checkRecording(opts)

  use_mouse = opts.INTERFACE.use_mouse;
	err = false;
	if ( use_mouse )
		return;
  end
	err = Eyelink( 'CheckRecording' );
end

%Close down the Eyelink connection and download the file.
function shutdownEyelink(opts)

if ( ~opts.INTERFACE.use_eyelink )
  return;
end

edf_filename = opts.IO.edf_filename;

WaitSecs( 0.1 );
Eyelink( 'StopRecording' );
WaitSecs( 0.1 );
Eyelink( 'CloseFile' );
WaitSecs( 0.1 );

try
  fprintf( 'Receiving data file ''%s''\n', edf_filename );
  %   Request the file
  status = Eyelink( 'ReceiveFile', edf_filename, pwd, 1 );
  if ( status > 0 )
    fprintf( 'ReceiveFile status %d\n', status );
  end
  WaitSecs(0.1);
  if ( exist( edf_filename, 'file' ) == 2 )
    fprintf( 'Data file ''%s'' can be found in ''%s''\n', edf_filename, pwd );
  end
catch err
    fprintf( 'Problem receiving data file ''%s''\n', edf_filename );
    fprintf( '\n%s', err.message );
end

end